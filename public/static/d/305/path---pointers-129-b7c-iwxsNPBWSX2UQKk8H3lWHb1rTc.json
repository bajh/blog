{"data":{"markdownRemark":{"html":"<p>If you learned C in school, I suspect you approached the language from the ground-up, learning all about stack frames and memory segments before you wrote code that did anything all that useful. I've been learning C by jumping straight into a bigger project, and after knowing several other languages.  I've wanted a tutorial geared towards people who are used to thinking in higher level languages, so I'm going to try to write about my own process of getting familiar with C.</p>\n<h1>Heap and Stack</h1>\n<p>The biggest difference between C and any other language I've used is the manual memory management. In languages like Python, Java or Go, you can accomplish a lot without knowing that there's a distinction between the heap and the stack, and that pointers are a thing.</p>\n<p>If you aren't familiar with the stack and heap, the stack is an area that stores the data necessary for each function to execute. Every time you call a function, a new stack frame is created to store the function's arguments, any local variables, and other information like the location of the next line of code that needs to be run when the function completes. When a function finishes, its stack frame is removed from the stack. The heap, on the other hand, is a separate region of memory where data remains between function calls. Data is only removed from the heap when the program calls <code>free</code>, passing the data that's no longer needed.</p>\n<p>In languages like Python, arrays and objects aren't passed to functions directly - instead, they're passed as references to memory addresses (pointers), but the programmer is usually unaware of this, unlike in C, which treats pointers and values as different types. Further, the runtime for higher level languages is responsible for allocating space for arrays and objects in the heap, and, of course, for freeing up the space those objects live in when they aren't needed any more.</p>\n<p>But <em>why</em> do these types of data need to be allocated on the heap? Because they need to be passed around as pointers rather than values. Which leads us to ask...</p>\n<h1>Why are Arrays and Objects Pointers?</h1>\n<p>For a couple reasons, including:</p>\n<ol>\n<li>These data structures are often large, and moving them around in the stack space whenever you call a function would be expensive.</li>\n</ol>\n<p>Here's a piece of example code that passes a reference variable to a couple functions. Even though I'm really talking about why C works the way it does, I'll use Python to illustrate these concepts more succinctly.</p>\n<pre><code>def finalize(blog_post_text):\n    edit(blog_post_text)\n    publish(blog_post_text)\n\ndef publish(blog_post_text):\n    upload = create_request(blog_post_text)\n    send(upload)\n\nfinalize(\"a bunch of text\")\n</code></pre>\n<p>So let's look at what would happen if \"a bunch of text\" was allocated on the stack. Every time a function is called, a stack frame is pushed on top of the stack. Each stack frame holds a few pieces of information necessary for the instructions that make up the function call to find the data they need to operate on.</p>\n<p>One of these pieces of information is the data for the arguments that are passed to the function. When each function is called, every argument is copied to a new stack frame. So after <code>create_request</code> has been invoked, this is what our stack looks like:</p>\n<p><img src=\"/images/stack_pointer.png\" alt=\"copying values vs pointers to stack\"></p>\n<p>This is a problem for reasons of both memory utilization and CPU work. Imagine that \"a bunch of text is\", say, 2048 bytes. That means it'll take up 6144 bytes just for these function calls. Furthermore, copying all of that data, and then removing the stack frames when the function calls are over, is unnecessary work. If the argument is simply a pointer to a place in memory, we only need to push 8 bytes of data onto each stack frame for this argument. The function can follow the pointer to locate the string data it needs to use.</p>\n<ol start=\"2\">\n<li>In Python, strings are immutable, but if we were dealing with objects, we would also want to be able to modify those objects from within function calls, and have those changes be visible to other functions. For example, let's say we have a BlogPost class now, and a primitive proofread function that sets a list of words that have typos on the BlogPost (for simplicity, I made this a function instead of a method).</li>\n</ol>\n<pre><code>class BlogPost:\n    def __init__(self, text):\n        self.text = text\n        self.ready = False\n\ndef proofread(blog_post):\n    typos = [word for word in blog_post.text.split() if word not in dictionary]\n    blog_post.ready  = len(typos) == 0\n\ndef correct(blog_post):\n    proofread(blog_post)\n    if not blog_post.ready:\n        show_errors(blog_post)\n</code></pre>\n<p>If <code>blog_post</code> were allocated on the stack, the only way for the change to the <code>ready</code> field to be communicated back to the caller of <code>proofread</code> would be if <code>correct</code> returned a new <code>BlogPost</code>, in functional style.</p>\n<p><img src=\"/images/stack_modification.png\" alt=\"Arguments pushed onto the stack cannot be modified in place\"></p>\n<p>One interesting aside: some high-level languages actually let the programmer decide whether object-like bundles of data should be allocated on the stack or the heap. In Swift, <code>struct</code> types are copied as values to each stack frame, whereas <code>class</code> types live in the heap. There are a couple reasons you might want data to not appear on the heap, including that allocating and garbage collecting heap objects is more expensive.</p>\n<p>So now we understand why we want to pass around pointers instead of values for these types of data. But this brings us back to our earlier question...</p>\n<h1>Why Can't Pointers Just Be on the Stack?</h1>\n<p>If you want to return a pointer from a function in C, that pointer cannot be to a variable on the stack, or you're asking for a SEGFAULT. Here's a piece of code that will cause mayhem (or, just not compile if you have the <code>-Wreturn-local-addr</code> flag on). Now we have to switch over to C because we're going to be showing explicit pointer variables.</p>\n<p>Pretend this <code>show_post</code> function is grabbing a post from a database or something and then displaying it.</p>\n<pre><code>typedef struct BlogPost {\n  int id;\n  char *text;\n} BlogPost;\n\nstruct BlogPost *get_post(int id)\n{\n  BlogPost post = { .id = id, .text = \"hi\" };\n\n  return &#x26;post;\n}\n\nvoid show_post(int id)\n{\n  BlogPost *post = get_post(); \n  printf(\"%s\\n\", post->text); \n}\n</code></pre>\n<p>You can see what happens in the diagram below. The pointer returned by <code>get_post</code> is a pointer to a location in the stack. But by the time the caller of that function is able to use that pointer, the stack frame where the data was initially stored has been popped. So, what was formerly the stack frame for <code>get_post</code> is now dangerous uncharted territory where dragons and bears and people with torsos for hands and hands for torsos roam. No sane person would ever venture to this land. And no sane person would ever return a stack pointer from a function.</p>\n<p><img src=\"/images/stack_variable.png\" alt=\"A stack pointer cannot safely be returned from a function\"></p>","frontmatter":{"title":"C Pointers"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"pathSlug":"/pointers","prev":null,"next":null}}